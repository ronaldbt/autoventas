import { parseURL } from 'ufo';
import { parse, walkSync, ELEMENT_NODE } from 'ultrahtml';

function isValidUrl(url) {
  if (!url || typeof url !== "string") return false;
  const trimmed = url.trim();
  if (!trimmed) return false;
  if (trimmed.startsWith("data:") || trimmed.startsWith("blob:") || trimmed.startsWith("file:")) {
    return false;
  }
  try {
    const parsed = parseURL(trimmed);
    return !!(parsed.protocol && parsed.host) || !!parsed.pathname;
  } catch {
    return false;
  }
}
function isValidString(value) {
  return typeof value === "string" && value.trim().length > 0;
}
function sanitizeString(value) {
  if (!isValidString(value)) return "";
  return String(value).trim().replace(/[\x00-\x1F\x7F-\x9F]/g, "");
}
function isValidDate(dateString) {
  if (!dateString) return false;
  const date = new Date(dateString);
  return !Number.isNaN(date.getTime()) && date.getFullYear() > 1900 && date.getFullYear() < 3e3;
}
function parseHtmlExtractSitemapMeta(html, options) {
  options = options || { images: true, videos: true, lastmod: true, alternatives: true };
  const payload = {};
  const resolveUrl = options?.resolveUrl || ((s) => s);
  let doc;
  try {
    doc = parse(html);
  } catch (error) {
    console.warn("Failed to parse HTML:", error);
    return payload;
  }
  let mainElement = null;
  const images = /* @__PURE__ */ new Set();
  const videos = [];
  const videoSources = /* @__PURE__ */ new Map();
  let articleModifiedTime;
  const alternatives = [];
  walkSync(doc, (node) => {
    if (node.type === ELEMENT_NODE) {
      const element = node;
      const attrs = element.attributes || {};
      if (element.name === "main" && !mainElement) {
        mainElement = element;
      }
      if (options?.lastmod && element.name === "meta") {
        const property = sanitizeString(attrs.property);
        const content = sanitizeString(attrs.content);
        if (property === "article:modified_time" && content && isValidDate(content)) {
          articleModifiedTime = content;
        }
      }
      if (options?.alternatives && element.name === "link") {
        const rel = sanitizeString(attrs.rel);
        const href = sanitizeString(attrs.href);
        const hreflang = sanitizeString(attrs.hreflang);
        if (rel === "alternate" && href && hreflang && isValidUrl(href)) {
          const hreflangPattern = /^[a-z]{2}(?:-[A-Z]{2})?$|^x-default$/;
          if (hreflangPattern.test(hreflang)) {
            try {
              const parsed = parseURL(href);
              if (parsed.pathname) {
                alternatives.push({
                  hreflang,
                  href: parsed.pathname
                });
              }
            } catch {
            }
          }
        }
      }
    }
  });
  const searchScope = mainElement || doc;
  walkSync(searchScope, (node) => {
    if (node.type === ELEMENT_NODE) {
      const element = node;
      const attrs = element.attributes || {};
      if (options?.images && element.name === "img") {
        const src = sanitizeString(attrs.src);
        if (src && isValidUrl(src)) {
          const resolvedUrl = resolveUrl(src);
          if (isValidUrl(resolvedUrl)) {
            images.add(resolvedUrl);
          }
        }
      }
      if (options?.videos && element.name === "video") {
        const content_loc = sanitizeString(attrs.src);
        const thumbnail_loc = sanitizeString(attrs.poster);
        const title = sanitizeString(attrs["data-title"]);
        const description = sanitizeString(attrs["data-description"]);
        if (!title || !description) {
          return;
        }
        const videoObj = {
          content_loc,
          thumbnail_loc,
          title,
          description
        };
        const player_loc = sanitizeString(attrs["data-player-loc"]);
        if (player_loc && isValidUrl(player_loc)) {
          videoObj.player_loc = player_loc;
        }
        const duration = sanitizeString(attrs["data-duration"]);
        if (duration) {
          const parsedDuration = Number.parseInt(duration, 10);
          if (!Number.isNaN(parsedDuration) && parsedDuration > 0 && parsedDuration <= 28800) {
            videoObj.duration = parsedDuration;
          }
        }
        const expiration_date = sanitizeString(attrs["data-expiration-date"]);
        if (expiration_date && isValidDate(expiration_date)) {
          videoObj.expiration_date = expiration_date;
        }
        const rating = sanitizeString(attrs["data-rating"]);
        if (rating) {
          const parsedRating = Number.parseFloat(rating);
          if (!Number.isNaN(parsedRating) && parsedRating >= 0 && parsedRating <= 5) {
            videoObj.rating = parsedRating;
          }
        }
        const view_count = sanitizeString(attrs["data-view-count"]);
        if (view_count) {
          const parsedViewCount = Number.parseInt(view_count, 10);
          if (!Number.isNaN(parsedViewCount) && parsedViewCount >= 0) {
            videoObj.view_count = parsedViewCount;
          }
        }
        const publication_date = sanitizeString(attrs["data-publication-date"]);
        if (publication_date && isValidDate(publication_date)) {
          videoObj.publication_date = publication_date;
        }
        const family_friendly = sanitizeString(attrs["data-family-friendly"]);
        if (family_friendly && ["yes", "no"].includes(family_friendly.toLowerCase())) {
          videoObj.family_friendly = family_friendly.toLowerCase();
        }
        const requires_subscription = sanitizeString(attrs["data-requires-subscription"]);
        if (requires_subscription && ["yes", "no"].includes(requires_subscription.toLowerCase())) {
          videoObj.requires_subscription = requires_subscription.toLowerCase();
        }
        const live = sanitizeString(attrs["data-live"]);
        if (live && ["yes", "no"].includes(live.toLowerCase())) {
          videoObj.live = live.toLowerCase();
        }
        const tag = sanitizeString(attrs["data-tag"]);
        if (tag && tag.length <= 256) {
          videoObj.tag = tag;
        }
        videos.push({ videoObj, element });
      }
      if (options?.videos && element.name === "source" && element.parent && element.parent.name === "video") {
        const videoElement = element.parent;
        const src = sanitizeString(attrs.src);
        if (src && isValidUrl(src)) {
          if (!videoSources.has(videoElement)) {
            videoSources.set(videoElement, []);
          }
          videoSources.get(videoElement).push(src);
        }
      }
    }
  });
  if (options?.images && images.size > 0) {
    payload.images = [...images].map((i) => ({ loc: i }));
  }
  if (options?.videos) {
    const processedVideos = [];
    for (const { videoObj, element } of videos) {
      const sources = videoSources.get(element) || [];
      if (sources.length > 0) {
        for (const source of sources) {
          const resolvedVideoObj = { ...videoObj };
          if (resolvedVideoObj.thumbnail_loc) {
            resolvedVideoObj.thumbnail_loc = resolveUrl(String(resolvedVideoObj.thumbnail_loc));
          }
          processedVideos.push({
            ...resolvedVideoObj,
            content_loc: resolveUrl(source)
          });
        }
      } else {
        processedVideos.push(videoObj);
      }
    }
    const validVideos = processedVideos.filter((v) => {
      return isValidString(v.title) && isValidString(v.description) && isValidString(v.content_loc) && isValidUrl(v.content_loc) && isValidString(v.thumbnail_loc) && isValidUrl(v.thumbnail_loc) && v.title.length <= 2048 && v.description.length <= 2048;
    });
    if (validVideos.length > 0) {
      payload.videos = validVideos;
    }
  }
  if (options?.lastmod && articleModifiedTime) {
    payload.lastmod = articleModifiedTime;
  }
  if (options?.alternatives && alternatives.length > 0 && (alternatives.length > 1 || alternatives[0].hreflang !== "x-default")) {
    payload.alternatives = alternatives;
  }
  return payload;
}

export { parseHtmlExtractSitemapMeta as p };
