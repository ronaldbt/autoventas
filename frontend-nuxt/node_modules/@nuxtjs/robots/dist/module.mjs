import fsp from 'node:fs/promises';
import { useNuxt, loadNuxtModuleInstance, useLogger, hasNuxtModule, getNuxtModuleVersion, hasNuxtModuleCompatibility, defineNuxtModule, createResolver, addImports, addPlugin, addTypeTemplate, addServerHandler, addServerPlugin, addServerImportsDir } from '@nuxt/kit';
import { defu } from 'defu';
import { installNuxtSiteConfig, updateSiteConfig } from 'nuxt-site-config/kit';
import { relative } from 'pathe';
import { readPackageJSON } from 'pkg-types';
import { withoutTrailingSlash, withTrailingSlash } from 'ufo';
import { N as NonHelpfulBots, A as AiBots } from './shared/robots.DDgLOylu.mjs';
import { existsSync } from 'node:fs';
import { provider, env } from 'std-env';
import { mergeOnKey, isInternalRoute, parseRobotsTxt, validateRobots, asArray, normalizeGroup } from '../dist/runtime/util.js';
import { ROBOT_DIRECTIVE_VALUES, formatMaxImagePreview, formatMaxSnippet, formatMaxVideoPreview } from '../dist/runtime/const.js';
import { normaliseRobotsRouteRule } from '../dist/runtime/server/nitro.js';

const DEVTOOLS_UI_ROUTE = "/__nuxt-robots";
const DEVTOOLS_UI_LOCAL_PORT = 3030;
function setupDevToolsUI(options, resolve, nuxt = useNuxt()) {
  const clientPath = resolve("./client");
  const isProductionBuild = existsSync(clientPath);
  if (isProductionBuild) {
    nuxt.hook("vite:serverCreated", async (server) => {
      const sirv = await import('sirv').then((r) => r.default || r);
      server.middlewares.use(
        DEVTOOLS_UI_ROUTE,
        sirv(clientPath, { dev: true, single: true })
      );
    });
  } else {
    nuxt.hook("vite:extendConfig", (config) => {
      config.server = config.server || {};
      config.server.proxy = config.server.proxy || {};
      config.server.proxy[DEVTOOLS_UI_ROUTE] = {
        target: `http://localhost:${DEVTOOLS_UI_LOCAL_PORT}${DEVTOOLS_UI_ROUTE}`,
        changeOrigin: true,
        followRedirects: true,
        rewrite: (path) => path.replace(DEVTOOLS_UI_ROUTE, "")
      };
    });
  }
  nuxt.hook("devtools:customTabs", (tabs) => {
    tabs.push({
      // unique identifier
      name: "nuxt-robots",
      // title to display in the tab
      title: "Robots",
      // any icon from Iconify, or a URL to an image
      icon: "carbon:bot",
      // iframe view
      view: {
        type: "iframe",
        src: DEVTOOLS_UI_ROUTE
      }
    });
  });
}

const autodetectableProviders = {
  azure_static: "azure",
  cloudflare_pages: "cloudflare-pages",
  netlify: "netlify",
  stormkit: "stormkit",
  vercel: "vercel",
  cleavr: "cleavr",
  stackblitz: "stackblitz"
};
const autodetectableStaticProviders = {
  netlify: "netlify-static",
  vercel: "vercel-static"
};
function detectTarget(options = {}) {
  return options?.static ? autodetectableStaticProviders[provider] : autodetectableProviders[provider];
}
function resolveNitroPreset(nitroConfig) {
  if (provider === "stackblitz" || provider === "codesandbox")
    return provider;
  let preset;
  if (nitroConfig && nitroConfig?.preset)
    preset = nitroConfig.preset;
  if (!preset)
    preset = env.NITRO_PRESET || detectTarget() || "node-server";
  return preset.replace("_", "-");
}
async function getNuxtModuleOptions(module, nuxt = useNuxt()) {
  const moduleMeta = ({ name: module } ) || {};
  const { nuxtModule } = await loadNuxtModuleInstance(module, nuxt);
  let moduleEntry;
  for (const m of nuxt.options.modules) {
    if (Array.isArray(m) && m.length >= 2) {
      const _module = m[0];
      const _moduleEntryName = typeof _module === "string" ? _module : (await _module.getMeta?.())?.name || "";
      if (_moduleEntryName === moduleMeta.name)
        moduleEntry = m;
    }
  }
  let inlineOptions = {};
  if (moduleEntry)
    inlineOptions = moduleEntry[1];
  if (nuxtModule.getOptions)
    return nuxtModule.getOptions(inlineOptions, nuxt);
  return inlineOptions;
}
function isNuxtGenerate(nuxt = useNuxt()) {
  return nuxt.options.nitro.static || nuxt.options._generate || [
    "static",
    "github-pages"
  ].includes(resolveNitroPreset(nuxt.options.nitro));
}

const logger = useLogger("@nuxt/robots");

function splitPathForI18nLocales(path, autoI18n) {
  const locales = autoI18n.strategy === "prefix_except_default" ? autoI18n.locales.filter((l) => l.code !== autoI18n.defaultLocale) : autoI18n.locales;
  if (!path || isInternalRoute(path))
    return path;
  const match = path.match(new RegExp(`^/(${locales.map((l) => l.code).join("|")})(.*)`));
  const locale = match?.[1];
  if (locale)
    return path;
  return [
    // always add the original route to avoid redirects
    path,
    ...locales.map((l) => `/${l.code}${path}`)
  ];
}
async function resolveI18nConfig() {
  let nuxtI18nConfig = {};
  let resolvedAutoI18n = false;
  let normalisedLocales = [];
  if (hasNuxtModule("@nuxtjs/i18n")) {
    const i18nVersion = await getNuxtModuleVersion("@nuxtjs/i18n");
    if (!await hasNuxtModuleCompatibility("@nuxtjs/i18n", ">=8"))
      logger.warn(`You are using @nuxtjs/i18n v${i18nVersion}. For the best compatibility, please upgrade to @nuxtjs/i18n v8.0.0 or higher.`);
    nuxtI18nConfig = await getNuxtModuleOptions("@nuxtjs/i18n") || {};
    normalisedLocales = mergeOnKey((nuxtI18nConfig.locales || []).map((locale) => typeof locale === "string" ? { code: locale } : locale), "code");
    const usingI18nPages = Object.keys(nuxtI18nConfig.pages || {}).length;
    const hasI18nConfigForAlternatives = nuxtI18nConfig.differentDomains || usingI18nPages || nuxtI18nConfig.strategy !== "no_prefix" && nuxtI18nConfig.locales;
    if (hasI18nConfigForAlternatives) {
      resolvedAutoI18n = {
        differentDomains: nuxtI18nConfig.differentDomains,
        defaultLocale: nuxtI18nConfig.defaultLocale,
        locales: normalisedLocales,
        strategy: nuxtI18nConfig.strategy
      };
    }
  }
  return resolvedAutoI18n;
}

const module = defineNuxtModule({
  meta: {
    name: "@nuxtjs/robots",
    compatibility: {
      nuxt: ">=3.6.1"
    },
    configKey: "robots"
  },
  moduleDependencies: {
    "@nuxtjs/i18n": {
      version: ">=8",
      optional: true
    },
    "nuxt-i18n-micro": {
      version: ">=1",
      optional: true
    },
    "nuxt-site-config": {
      version: ">=3"
    },
    "@nuxt/content": {
      version: ">=2",
      optional: true
    }
  },
  defaults: {
    enabled: true,
    credits: true,
    debug: false,
    allow: [],
    disallow: [],
    sitemap: [],
    groups: [],
    blockNonSeoBots: false,
    mergeWithRobotsTxtPath: true,
    header: true,
    metaTag: true,
    cacheControl: "max-age=14400, must-revalidate",
    robotsEnabledValue: ROBOT_DIRECTIVE_VALUES.enabled,
    robotsDisabledValue: ROBOT_DIRECTIVE_VALUES.disabled,
    disallowNonIndexableRoutes: false,
    robotsTxt: true,
    botDetection: true
  },
  async setup(config, nuxt) {
    const { resolve } = createResolver(import.meta.url);
    const { version } = await readPackageJSON(resolve("../package.json"));
    logger.level = config.debug || nuxt.options.debug ? 4 : 3;
    if (config.enabled === false) {
      logger.debug("The module is disabled, skipping setup.");
      addImports({ name: "useRobotsRule", from: resolve(`./runtime/app/composables/mock`) });
      nuxt.options.nitro = nuxt.options.nitro || {};
      nuxt.options.nitro.imports = nuxt.options.nitro.imports || {};
      nuxt.options.nitro.imports.presets = nuxt.options.nitro.imports.presets || [];
      nuxt.options.nitro.imports.presets.push({
        from: resolve("./runtime/server/mock-composables"),
        imports: [
          "getPathRobotConfig",
          "getSiteRobotConfig"
        ]
      });
      return;
    }
    if (nuxt.options.app.baseURL?.length > 1 && config.robotsTxt) {
      logger.error(`You are not allowed to generate a robots.txt with a base URL, please set \`{ robots: { robotsTxt: false } }\` in your nuxt.config.`);
      config.robotsTxt = false;
    }
    const resolvedAutoI18n = typeof config.autoI18n === "boolean" ? false : config.autoI18n || await resolveI18nConfig();
    if (config.blockNonSeoBots) {
      config.groups.push({
        userAgent: NonHelpfulBots,
        comment: ["Block non helpful bots"],
        disallow: ["/"]
      });
    }
    if (config.blockAiBots) {
      config.groups.push({
        userAgent: AiBots,
        comment: ["Block AI Crawlers"],
        disallow: ["/"]
      });
    }
    await installNuxtSiteConfig();
    if (config.metaTag)
      addPlugin({ mode: "server", src: resolve("./runtime/app/plugins/robot-meta.server") });
    if (config.robotsTxt && config.mergeWithRobotsTxtPath !== false) {
      let usingRobotsTxtPath = "";
      let robotsTxt = false;
      const publicRobotsTxtPath = resolve(nuxt.options.rootDir, nuxt.options.dir.public, "robots.txt");
      const validPaths = [
        // public/robots.txt - This is the default, we need to move this to avoid issues
        publicRobotsTxtPath,
        // assets/robots.txt
        resolve(nuxt.options.rootDir, nuxt.options.dir.assets, "robots.txt"),
        // public/_robots.txt
        resolve(nuxt.options.rootDir, nuxt.options.dir.public, "_robots.txt"),
        // public/_robots.txt
        resolve(nuxt.options.rootDir, nuxt.options.dir.public, "_robots.txt"),
        // public/_dir/robots.txt
        resolve(nuxt.options.rootDir, nuxt.options.dir.public, "_dir", "robots.txt"),
        // pages/_dir/robots.txt
        resolve(nuxt.options.rootDir, nuxt.options.dir.pages, "_dir", "robots.txt"),
        // pages/robots.txt
        resolve(nuxt.options.rootDir, nuxt.options.dir.pages, "robots.txt"),
        // robots.txt
        resolve(nuxt.options.rootDir, "robots.txt")
      ];
      if (config.mergeWithRobotsTxtPath === true) {
        for (const path of validPaths) {
          robotsTxt = await fsp.readFile(path, { encoding: "utf-8" }).catch(() => false);
          if (robotsTxt) {
            usingRobotsTxtPath = path;
            break;
          }
        }
      } else {
        const customPath = resolve(nuxt.options.rootDir, config.mergeWithRobotsTxtPath);
        if (!await fsp.stat(customPath).catch(() => false)) {
          logger.error(`You provided an invalid \`mergeWithRobotsTxtPath\`, the file does not exist: ${customPath}.`);
        } else {
          usingRobotsTxtPath = customPath;
          robotsTxt = await fsp.readFile(customPath, { encoding: "utf-8" });
        }
      }
      if (typeof robotsTxt === "string") {
        const path = relative(nuxt.options.rootDir, usingRobotsTxtPath);
        logger.debug(`A robots.txt file was found at \`./${path}\`, merging config.`);
        const parsedRobotsTxt = parseRobotsTxt(robotsTxt);
        const { errors } = validateRobots(parsedRobotsTxt);
        if (errors.length > 0) {
          logger.error(`The \`./${path}\` file contains errors:`);
          for (const error of errors)
            logger.log(` - ${error}`);
          logger.log("");
        }
        const wildCardGroups = parsedRobotsTxt.groups.filter((group) => asArray(group.userAgent).includes("*"));
        if (wildCardGroups.some((group) => asArray(group.disallow).includes("/"))) {
          logger.warn(`The \`./${path}\` is blocking indexing for all environments.`);
          logger.info("It's recommended to use the `indexable` Site Config to toggle this instead.");
        }
        config.groups.push(...parsedRobotsTxt.groups);
        const host = parsedRobotsTxt.groups.map((g) => g.host).filter(Boolean)[0];
        if (host) {
          updateSiteConfig({
            _context: usingRobotsTxtPath,
            url: host
          });
        }
        config.sitemap = [.../* @__PURE__ */ new Set([...asArray(config.sitemap), ...parsedRobotsTxt.sitemaps])];
        if (usingRobotsTxtPath === publicRobotsTxtPath) {
          await fsp.rename(usingRobotsTxtPath, resolve(nuxt.options.rootDir, nuxt.options.dir.public, "_robots.txt"));
          logger.warn("Your robots.txt file was moved to `./public/_robots.txt` to avoid conflicts.");
          const extraPaths = [];
          for (const path2 of validPaths) {
            if (path2 !== usingRobotsTxtPath)
              extraPaths.push(` - ./${relative(nuxt.options.rootDir, path2)}`);
          }
          logger.info(`The following paths are also valid for your robots.txt:
${extraPaths.join("\n")}
`);
        }
      }
    }
    const nitroPreset = resolveNitroPreset(nuxt.options.nitro);
    const usingNuxtContent = hasNuxtModule("@nuxt/content");
    const isNuxtContentV3 = usingNuxtContent && await hasNuxtModuleCompatibility("@nuxt/content", "^3");
    let isNuxtContentV2 = usingNuxtContent && await hasNuxtModuleCompatibility("@nuxt/content", "^2");
    if (isNuxtContentV3) {
      if (nuxt.options._installedModules.some((m) => m.meta.name === "Content")) {
        logger.warn("You have loaded `@nuxt/content` before `@nuxtjs/robots`, this may cause issues with the integration. Please ensure `@nuxtjs/robots` is loaded first.");
      }
      nuxt.hooks.hook("content:file:afterParse", (ctx) => {
        if (typeof ctx.content.robots !== "undefined") {
          let rule = ctx.content.robots;
          if (typeof rule === "boolean") {
            rule = rule ? config.robotsEnabledValue : config.robotsDisabledValue;
          } else if (typeof rule === "object" && rule !== null) {
            const directives = [];
            for (const [key, value] of Object.entries(rule)) {
              if (value === false || value === null || value === void 0)
                continue;
              if (key in ROBOT_DIRECTIVE_VALUES && typeof value === "boolean" && value) {
                directives.push(ROBOT_DIRECTIVE_VALUES[key]);
              } else if (key === "max-image-preview" && typeof value === "string") {
                directives.push(formatMaxImagePreview(value));
              } else if (key === "max-snippet" && typeof value === "number") {
                directives.push(formatMaxSnippet(value));
              } else if (key === "max-video-preview" && typeof value === "number") {
                directives.push(formatMaxVideoPreview(value));
              }
            }
            rule = directives.join(", ") || config.robotsEnabledValue;
          }
          ctx.content.seo = ctx.content.seo || {};
          ctx.content.seo.robots = rule;
        }
      });
    } else if (isNuxtContentV2 && nitroPreset.startsWith("cloudflare")) {
      logger.warn("The Nuxt Robots, Nuxt Content integration does not work with CloudFlare yet, the integration will be disabled. Learn more at: https://nuxtseo.com/docs/robots/guides/content");
      isNuxtContentV2 = false;
    }
    nuxt.hook("modules:done", async () => {
      config.sitemap = asArray(config.sitemap);
      config.disallow = asArray(config.disallow);
      config.allow = asArray(config.allow);
      config.groups = config.groups.map(normalizeGroup);
      const existingGroup = config.groups.find((stack) => stack.userAgent.length === 1 && stack.userAgent[0] === "*");
      if (existingGroup) {
        existingGroup.disallow = [.../* @__PURE__ */ new Set([...existingGroup.disallow || [], ...config.disallow])];
        if (existingGroup.disallow.length > 1) {
          existingGroup.disallow = existingGroup.disallow.filter((disallow) => disallow !== "");
        }
        existingGroup.allow = [.../* @__PURE__ */ new Set([...existingGroup.allow || [], ...config.allow])];
      } else {
        config.groups.unshift({
          userAgent: ["*"],
          disallow: config.disallow.length > 0 ? config.disallow : [""],
          allow: config.allow
        });
      }
      await nuxt.hooks.callHook("robots:config", config);
      nuxt.options.routeRules = nuxt.options.routeRules || {};
      if (config.header) {
        const noIndexPaths = [withoutTrailingSlash(nuxt.options.app.buildAssetsDir), `${nuxt.options.app.buildAssetsDir}**`];
        for (const path of noIndexPaths) {
          nuxt.options.routeRules[path] = defu({
            robots: "noindex"
          }, nuxt.options.routeRules[path]);
        }
        Object.entries(nuxt.options.routeRules).forEach(([route, rules]) => {
          const robotRule = normaliseRobotsRouteRule(rules);
          if (robotRule && !robotRule.allow && robotRule.rule) {
            nuxt.options.routeRules[route] = defu({
              headers: {
                "X-Robots-Tag": robotRule.rule
              }
            }, nuxt.options.routeRules?.[route]);
          }
        });
      }
      const extraDisallows = /* @__PURE__ */ new Set();
      if (config.disallowNonIndexableRoutes) {
        Object.entries(nuxt.options.routeRules || {}).forEach(([route, rules]) => {
          const url = route.split("/").map((segment) => segment.startsWith(":") ? "*" : segment).join("/");
          const robotsRule = normaliseRobotsRouteRule(rules);
          if (robotsRule && !robotsRule.allow) {
            extraDisallows.add(url.replaceAll("**", "*"));
          }
        });
      }
      const firstGroup = config.groups.find((group) => group.userAgent.includes("*"));
      if (firstGroup)
        firstGroup.disallow = [.../* @__PURE__ */ new Set([...firstGroup.disallow || [], ...extraDisallows])];
      if (resolvedAutoI18n && resolvedAutoI18n.locales && resolvedAutoI18n.strategy !== "no_prefix") {
        const i18n = resolvedAutoI18n;
        for (const group of config.groups.filter((g) => !g._skipI18n)) {
          group.allow = asArray(group.allow || []).map((path) => splitPathForI18nLocales(path, i18n)).flat();
          group.disallow = asArray(group.disallow || []).map((path) => splitPathForI18nLocales(path, i18n)).flat();
        }
      }
      const groups = config.groups.map(normalizeGroup);
      const pathsToCheck = [
        withoutTrailingSlash(nuxt.options.app.buildAssetsDir),
        nuxt.options.app.buildAssetsDir,
        "/api",
        "/api/"
      ];
      for (const p of pathsToCheck) {
        if (groups.some((g) => g.disallow.includes(p))) {
          logger.warn(`You have disallowed robots accessing \`${withTrailingSlash(p)}**\`, this may prevent your site from being indexed correctly.`);
        }
      }
      const robotsRuntimeConfig = {
        version: version || "",
        isNuxtContentV2,
        debug: config.debug,
        credits: config.credits,
        groups,
        sitemap: config.sitemap,
        header: config.header,
        robotsEnabledValue: config.robotsEnabledValue,
        robotsDisabledValue: config.robotsDisabledValue,
        cacheControl: config.cacheControl ?? "max-age=14400, must-revalidate",
        botDetection: config.botDetection ?? true
      };
      nuxt.options.runtimeConfig["nuxt-robots"] = robotsRuntimeConfig;
    });
    addTypeTemplate({
      filename: "module/nuxt-robots.d.ts",
      getContents: (data) => {
        const typesPath = relative(resolve(data.nuxt.options.rootDir, data.nuxt.options.buildDir, "module"), resolve("runtime/types"));
        const types = `  interface NitroApp {
    _robots: {
      ctx: import('${typesPath}').HookRobotsConfigContext
      nuxtContentUrls?: Set<string>
    },
    _robotsRuleMatcher: (url: string) => any
    _robotsPatternMap?: Map<string, import('${typesPath}').PatternMapValue>
  }
  interface NitroRouteRules {
    robots?: import('${typesPath}').RobotsValue | {
      indexable: boolean
      rule: string
    }
  }
  interface NitroRouteConfig {
    robots?: import('${typesPath}').RobotsValue | {
      indexable: boolean
      rule: string
    }
  }
  interface NitroRuntimeHooks {
    'robots:config': (ctx: import('${typesPath}').HookRobotsConfigContext) => void | Promise<void>
    'robots:robots-txt': (ctx: import('${typesPath}').HookRobotsTxtContext) => void | Promise<void>
  }`;
        return `// Generated by nuxt-robots

import type { RobotsContext } from '#robots/types'

declare module 'nitropack/types' {
${types}
}

declare module 'nitropack' {
${types}
}

declare module 'h3' {
  interface H3EventContext {
    robots: RobotsContext
  }
}

export {}
`;
      }
    }, {
      nitro: true,
      nuxt: true
    });
    const isFirebase = nitroPreset === "firebase";
    if ((isNuxtGenerate() || isFirebase) && config.robotsTxt) {
      nuxt.options.nitro.prerender = nuxt.options.nitro.prerender || {};
      nuxt.options.nitro.prerender.routes = nuxt.options.nitro.prerender.routes || [];
      nuxt.options.nitro.prerender.routes.push("/robots.txt");
      if (isFirebase)
        logger.info("Firebase does not support dynamic robots.txt files. Prerendering /robots.txt.");
    }
    addImports({
      name: "useRobotsRule",
      from: resolve("./runtime/app/composables/useRobotsRule")
    });
    if (config.botDetection) {
      addImports({
        name: "useBotDetection",
        from: resolve("./runtime/app/composables/useBotDetection")
      });
    } else {
      addImports({
        name: "useBotDetection",
        from: resolve("./runtime/app/composables/mock")
      });
    }
    if (config.robotsTxt) {
      addServerHandler({
        route: "/robots.txt",
        handler: resolve("./runtime/server/routes/robots-txt")
      });
    }
    addServerHandler({
      middleware: true,
      handler: resolve("./runtime/server/middleware/injectContext")
    });
    addServerPlugin(resolve("./runtime/server/plugins/initContext"));
    if (isNuxtContentV2) {
      addServerHandler({
        route: "/__robots__/nuxt-content.json",
        handler: resolve("./runtime/server/routes/__robots__/nuxt-content-v2")
      });
    }
    if (config.debug || nuxt.options.dev) {
      addServerHandler({
        route: "/__robots__/debug.json",
        handler: resolve("./runtime/server/routes/__robots__/debug")
      });
      addServerHandler({
        route: "/__robots__/debug-path.json",
        handler: resolve("./runtime/server/routes/__robots__/debug-path")
      });
    }
    if (nuxt.options.dev)
      setupDevToolsUI(config, resolve);
    addServerImportsDir(resolve("./runtime/server/composables"));
    if (!config.botDetection) {
      nuxt.options.nitro.imports = nuxt.options.nitro.imports || {};
      nuxt.options.nitro.imports.presets = nuxt.options.nitro.imports.presets || [];
      nuxt.options.nitro.imports.presets.push({
        from: resolve("./runtime/server/mock-composables"),
        imports: [
          "getBotDetection",
          "isBot",
          "getBotInfo"
        ]
      });
    }
    nuxt.options.nitro.alias = nuxt.options.nitro.alias || {};
    nuxt.options.nitro.alias["#internal/nuxt-simple-robots"] = resolve("./runtime/server/composables");
    nuxt.options.nitro.alias["#internal/nuxt-robots"] = resolve("./runtime/server/composables");
    nuxt.options.alias["#robots"] = resolve("./runtime");
  }
});

export { module as default };
