import { useNuxt, addTypeTemplate, defineNuxtModule, useLogger, createResolver, addServerHandler, hasNuxtModule, addPlugin, addImports, addVitePlugin } from '@nuxt/kit';
import UnheadVite from '@unhead/addons/vite';
import { defu } from 'defu';
import { installNuxtSiteConfig } from 'nuxt-site-config/kit';
import { resolve, relative, extname, dirname, basename } from 'pathe';
import { unpackMeta } from '@unhead/vue/utils';
import fg from 'fast-glob';
import fs from 'node:fs';
import { encodePath, joinURL } from 'ufo';
import escapeRE from 'escape-string-regexp';
import { readFile } from 'node:fs/promises';
import imageSize from 'image-size';

function extendNuxtConfigAppHeadSeoMeta(nuxt = useNuxt()) {
  const seoMeta = nuxt.options.app?.seoMeta || nuxt.options.app?.head?.seoMeta || {};
  const configSeoMeta = nuxt.options.seo?.meta || nuxt.options.seo?.seoMeta || {};
  if (!seoMeta && !configSeoMeta)
    return;
  nuxt.options.app.head = nuxt.options.app.head || {};
  nuxt.options.app.head = {
    ...nuxt.options.app.head,
    meta: [
      ...nuxt.options.app.head.meta || [],
      // @ts-expect-error untyped
      ...unpackMeta(seoMeta),
      ...unpackMeta(configSeoMeta || {})
    ]
  };
  delete nuxt.options.app.seoMeta;
  delete nuxt.options.app.head.seoMeta;
}

function extendNuxtConfigAppHeadTypes(nuxt = useNuxt()) {
  addTypeTemplate({
    filename: "module/nuxt-seo-utils.assets.d.ts",
    getContents: async () => {
      const paths = (await fg(["**/*"], { cwd: resolve(nuxt.options.srcDir, "public") })).map((p) => `/${p}`);
      const jsPaths = paths.filter((p) => p.endsWith(".js") || p.endsWith(".mjs"));
      return `// Generated by nuxt-seo-utils
declare module '#app' {
  import { HeadEntry, HeadTag } from '@unhead/vue/types'

  interface RuntimeNuxtHooks {
    'head:tags': (tag: HeadTag[]) => Promise<void> | void
    'head:entries': (entries: HeadEntry[]) => Promise<void> | void
  }
}
declare module '@unhead/schema' {

  type PublicFiles = ${[...paths.map((p) => `'${p}'`), "(string & Record<never, never>)"].join(" | ")}
  type JsFiles = ${[...jsPaths.map((p) => `'${p}'`), "(string & Record<never, never>)"].join(" | ")}

  interface SchemaAugmentations {
    link: import('@unhead/schema').UserTagConfigWithoutInnerContent & {
      href: PublicFiles
    }
    script: import('@unhead/schema').TagUserProperties & {
      src: JsFiles
    }
  }
}

export {}
`;
    }
  }, {
    nuxt: true
  });
}

const MetaTagFileGlobs = [
  "**/*og-image.{png,jpg,jpeg,gif}",
  "**/*opengraph-image.{png,jpg,jpeg,gif}",
  "**/*twitter-image.{png,jpg,jpeg,gif}",
  "**/*apple-icon.{jpg,jpeg,png}",
  "**/*apple-touch.{jpg,jpeg,png}",
  "**/*apple-touch-*.{jpg,jpeg,png}",
  "**/*apple-touch-icon.{jpg,jpeg,png}",
  "**/*apple-touch-icon-*.{jpg,jpeg,png}",
  "**/*icon.{ico,jpg,jpeg,png,svg}",
  "**/*icon-*.{ico,jpg,jpeg,png,svg}"
];

function generateNuxtPageFromFile(file, pagesDir) {
  const segments = relative(pagesDir, file).replace(new RegExp(`${escapeRE(extname(file))}$`), "").split("/");
  const route = {
    name: "",
    path: "",
    file,
    children: []
  };
  let parent = [];
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i] || "";
    const tokens = parseSegment(segment);
    const segmentName = tokens.map(({ value }) => value).join("");
    route.name += (route.name && "-") + segmentName;
    const child = parent.find((parentRoute) => parentRoute.name === route.name && !parentRoute.path.endsWith("(.*)*"));
    if (child && child.children) {
      parent = child.children;
      route.path = "";
    } else if (segmentName === "index" && !route.path) {
      route.path += "/";
    } else if (segmentName !== "index") {
      route.path += getRoutePath(tokens);
    }
  }
  if (route.name)
    route.name = route.name.replace(/-index$/, "");
  return route;
}
function getRoutePath(tokens) {
  return tokens.reduce((path, token) => {
    return path + (token.type === 2 /* optional */ ? `:${token.value}?` : token.type === 1 /* dynamic */ ? `:${token.value}` : token.type === 3 /* catchall */ ? `:${token.value}(.*)*` : encodePath(token.value));
  }, "/");
}
const PARAM_CHAR_RE = /[\w.]/;
function parseSegment(segment) {
  let state = 0 /* initial */;
  let i = 0;
  let buffer = "";
  const tokens = [];
  function consumeBuffer() {
    if (!buffer)
      return;
    if (state === 0 /* initial */)
      throw new Error("wrong state");
    tokens.push({
      type: state === 1 /* static */ ? 0 /* static */ : state === 2 /* dynamic */ ? 1 /* dynamic */ : state === 3 /* optional */ ? 2 /* optional */ : 3 /* catchall */,
      value: buffer
    });
    buffer = "";
  }
  while (i < segment.length) {
    const c = segment[i] || "";
    switch (state) {
      case 0 /* initial */:
        buffer = "";
        if (c === "[") {
          state = 2 /* dynamic */;
        } else {
          i--;
          state = 1 /* static */;
        }
        break;
      case 1 /* static */:
        if (c === "[") {
          consumeBuffer();
          state = 2 /* dynamic */;
        } else {
          buffer += c;
        }
        break;
      case 4 /* catchall */:
      case 2 /* dynamic */:
      case 3 /* optional */:
        if (buffer === "...") {
          buffer = "";
          state = 4 /* catchall */;
        }
        if (c === "[" && state === 2 /* dynamic */)
          state = 3 /* optional */;
        if (c === "]" && (state !== 3 /* optional */ || buffer[buffer.length - 1] === "]")) {
          if (!buffer)
            throw new Error("Empty param");
          else
            consumeBuffer();
          state = 0 /* initial */;
        } else if (PARAM_CHAR_RE.test(c)) {
          buffer += c;
        } else ;
        break;
    }
    i++;
  }
  if (state === 2 /* dynamic */)
    throw new Error(`Unfinished param "${buffer}"`);
  consumeBuffer();
  return tokens;
}

function hasLinkRel(input, rel) {
  return input.link?.some((link) => link.rel === rel);
}
function hasMetaProperty(input, property) {
  return input.meta?.some((meta) => meta.property === property);
}
async function getImageMeta(base, path, isIcon = false) {
  const absolutePath = resolve(base, path);
  const file = absolutePath.split("/").pop();
  const keyword = file.split(".")[0];
  let ext = absolutePath.split(".").pop();
  if (ext === "jpg")
    ext = "jpeg";
  const { width, height } = await getImageDimensions(absolutePath);
  const payload = {
    type: ext === "svg" ? `image/svg+xml` : `image/${ext}`
  };
  if (!isIcon) {
    payload.width = width;
    payload.height = height;
    const altTextPath = resolve(dirname(absolutePath), `${keyword}.alt.txt`);
    if (fs.existsSync(altTextPath)) {
      payload.alt = fs.readFileSync(altTextPath, "utf8");
      payload.alt = String(payload.alt).replace(/\n/g, " ").trim();
    }
  } else {
    if (path.includes(".dark") || path.includes("-dark"))
      payload.media = "(prefers-color-scheme: dark)";
    else if (path.includes(".light") || path.includes("-light"))
      payload.media = "(prefers-color-scheme: light)";
    if (ext !== "svg") {
      payload.sizes = `${width}x${height}`;
    } else {
      payload.sizes = "any";
    }
  }
  return payload;
}
async function getImageDimensions(absolutePath) {
  const buffer = await readFile(absolutePath);
  return imageSize(buffer);
}

async function generateTagsFromPageDirImages(nuxt = useNuxt()) {
  const pagesDir = resolve(nuxt.options.rootDir, nuxt.options.dir.pages);
  const files = await fg(MetaTagFileGlobs, { cwd: pagesDir, onlyFiles: true });
  const appendRouteRules = {};
  const devMiddlewareMap = {};
  const nitroOutputMap = [];
  for (const file of files) {
    const fileName = basename(file);
    const keyword = fileName.split(".")[0] || "";
    let { path } = generateNuxtPageFromFile(resolve(pagesDir, dirname(file)), pagesDir);
    const meta = await getImageMeta(pagesDir, file);
    if (path.endsWith("/_dir"))
      path = path.replace(/\/_dir$/, "");
    const src = joinURL(path, fileName);
    if (["icon", "apple-touch-icon", "apple-icon"].includes(keyword) || keyword.startsWith("icon-")) {
      appendRouteRules[`${path}/**`] = {
        head: {
          link: [
            { rel: keyword, type: meta.type, href: src, sizes: meta.sizes }
          ]
        }
      };
    } else {
      appendRouteRules[`${path}/**`] = {
        seoMeta: {
          [["opengraph-image", "og-image"].includes(keyword) ? "ogImage" : "twitterImage"]: [{ url: src, ...meta, sizes: void 0 }]
        }
      };
    }
    devMiddlewareMap[src] = resolve(pagesDir, file);
    nitroOutputMap.push({
      src: resolve(pagesDir, file),
      dest: src.slice(1)
      // remove leading slash
    });
  }
  nuxt.options.routeRules = defu(appendRouteRules, nuxt.options.routeRules);
  nuxt.options.nitro.routeRules = defu(appendRouteRules, nuxt.options.nitro.routeRules);
  if (nuxt.options.dev) {
    nuxt.hooks.hook("nitro:config", async (nitroConfig) => {
      nitroConfig.virtual["#seo-utils-virtual/pageDirImages"] = `export const fileMapping = ${JSON.stringify(devMiddlewareMap)}`;
    });
  }
  nuxt.hooks.hook("nitro:build:public-assets", (_nitro) => {
    const publicDir = resolve(_nitro.options.output.dir, _nitro.options.output.publicDir);
    nitroOutputMap.forEach(({ src, dest }) => {
      const resolvedDest = resolve(publicDir, dest);
      const destFolder = dirname(resolvedDest);
      if (!fs.existsSync(destFolder))
        fs.mkdirSync(destFolder, { recursive: true });
      if (!fs.existsSync(resolvedDest))
        fs.copyFileSync(src, resolvedDest);
    });
  });
}

async function generateTagsFromPublicFiles(nuxt = useNuxt()) {
  const publicDirPath = resolve(nuxt.options.rootDir, nuxt.options.dir.public);
  const rootPublicFiles = (await fg(MetaTagFileGlobs, { cwd: publicDirPath, onlyFiles: true, deep: 1 })).map((file) => basename(file));
  const headConfig = defu(nuxt.options.app.head, {
    link: [],
    meta: []
  });
  if (!hasLinkRel(headConfig, "icon")) {
    if (rootPublicFiles.includes("favicon.ico") && nuxt.options.app.baseURL !== "/") {
      headConfig.link.push({
        rel: "icon",
        href: joinURL(nuxt.options.app.baseURL, "favicon.ico"),
        sizes: "any"
      });
    }
    const isIcon = (file) => file.includes("icon") && !file.endsWith(".ico");
    const isAppleTouchIcon = (file) => file.includes("apple-icon") || file.includes("apple-touch-icon") || file.includes("apple-touch");
    headConfig.link.push(
      ...await Promise.all([
        ...rootPublicFiles.filter((file) => isIcon(file) && !isAppleTouchIcon(file)).sort().map(async (iconFile) => {
          const meta = await getImageMeta(publicDirPath, iconFile, true);
          return {
            rel: "icon",
            href: joinURL(nuxt.options.app.baseURL, iconFile),
            ...meta
          };
        }),
        ...rootPublicFiles.filter((file) => isAppleTouchIcon(file)).sort().map(async (appleIconFile) => {
          const meta = await getImageMeta(publicDirPath, appleIconFile, true);
          return {
            rel: "apple-touch-icon",
            href: joinURL(nuxt.options.app.baseURL, appleIconFile),
            ...meta
          };
        })
      ])
    );
  }
  let hasTwitterImage = hasMetaProperty(headConfig, "twitter:image");
  if (!hasTwitterImage) {
    const twitterImageFiles = rootPublicFiles.filter((file) => file.startsWith("twitter-image.")).sort();
    if (twitterImageFiles.length) {
      headConfig.meta.push(
        ...(await Promise.all(twitterImageFiles.map(async (twitterImageFile) => {
          const dimensions = await getImageDimensions(resolve(publicDirPath, twitterImageFile));
          return unpackMeta({
            twitterImage: {
              url: twitterImageFile,
              width: dimensions.width,
              height: dimensions.height
            }
          });
        }))).flat()
      );
      hasTwitterImage = true;
    }
  }
  if (!hasMetaProperty(headConfig, "og:image")) {
    const ogImageFiles = rootPublicFiles.filter((file) => file.startsWith("og-image.") || file.startsWith("og.")).sort();
    if (ogImageFiles.length) {
      headConfig.meta.push(
        ...(await Promise.all(ogImageFiles.map(async (src) => {
          const meta = await getImageMeta(publicDirPath, src, false);
          delete meta.sizes;
          const seoMeta = {
            ogImage: {
              url: src,
              ...meta
            }
          };
          if (!hasTwitterImage) {
            seoMeta.twitterImage = {
              url: src,
              ...meta
            };
          }
          return unpackMeta(seoMeta);
        }))).flat()
      );
    }
  }
  nuxt.options.app.head = headConfig;
}

function setupNuxtConfigAppHeadWithMoreDefaults(nuxt = useNuxt()) {
  const headConfig = nuxt.options.app.head;
  headConfig.link = headConfig.link || [];
  headConfig.htmlAttrs = headConfig.htmlAttrs || {};
  headConfig.link = headConfig.link || [];
  headConfig.meta = headConfig.meta || [];
  if (!hasMetaProperty(headConfig, "og:type")) {
    headConfig.meta.push({
      property: "og:type",
      content: "website"
    });
  }
  nuxt.options.app.head = headConfig;
}

const module = defineNuxtModule({
  meta: {
    name: "nuxt-seo-utils",
    configKey: "seo",
    compatibility: {
      nuxt: ">=3.16.0"
    }
  },
  moduleDependencies: {
    "@nuxtjs/i18n": {
      version: ">=8",
      optional: true
    },
    "nuxt-i18n-micro": {
      version: ">=1",
      optional: true
    },
    "nuxt-site-config": {
      version: ">=3"
    }
  },
  defaults: {
    enabled: true,
    debug: false,
    redirectToCanonicalSiteUrl: false,
    automaticDefaults: true,
    fallbackTitle: true,
    metaDataFiles: true,
    mergeWithSiteConfig: true,
    extendRouteRules: true,
    fixRequiredAbsoluteMetaTagsLinks: true,
    extendNuxtConfigAppHeadSeoMeta: true,
    treeShakeUseSeoMeta: true,
    extendNuxtConfigAppHeadTypes: true,
    setupNuxtConfigAppHeadWithMoreDefaults: true,
    automaticOgAndTwitterTags: true,
    canonicalLowercase: true
  },
  async setup(config, nuxt) {
    const logger = useLogger("nuxt-seo-utils");
    logger.level = config.debug || nuxt.options.debug ? 4 : 3;
    if (config.enabled === false) {
      logger.debug("The module is disabled, skipping setup.");
      return;
    }
    const { resolve } = createResolver(import.meta.url);
    await installNuxtSiteConfig();
    const runtimeDir = resolve("./runtime");
    if (config.metaDataFiles) {
      await generateTagsFromPublicFiles();
      await generateTagsFromPageDirImages();
      if (nuxt.options.dev) {
        addServerHandler({
          middleware: true,
          handler: resolve(runtimeDir, "server/middleware/resolveImagesInPagesDir")
        });
      }
    }
    const hasI18n = hasNuxtModule("@nuxtjs/i18n") || hasNuxtModule("nuxt-i18n-micro");
    if (config.automaticDefaults) {
      if (hasI18n) {
        addPlugin({
          src: resolve(runtimeDir, `./app/plugins/defaultsWaitI18n`)
        });
      } else {
        addPlugin({
          src: resolve(runtimeDir, `./app/plugins/defaults`)
        });
      }
    }
    if (config.fallbackTitle) {
      addPlugin({
        src: resolve(runtimeDir, "./app/plugins/titles")
      });
    }
    if (!hasI18n) {
      addImports({
        from: resolve(runtimeDir, `./app/composables/polyfills`),
        name: "useI18n"
      });
    }
    addImports({
      from: resolve(runtimeDir, `./app/composables/useBreadcrumbItems`),
      name: "useBreadcrumbItems"
    });
    const polyfills = [
      // @ts-expect-error runtime type
      ...!hasNuxtModule("nuxt-schema-org") || nuxt.options.schemaOrg?.enable === false ? [
        "useSchemaOrg",
        "defineWebSite",
        "defineWebPage",
        "defineBreadcrumb"
      ] : []
    ];
    polyfills.forEach((name) => {
      addImports({
        from: resolve(runtimeDir, "./app/composables/polyfills"),
        name
      });
    });
    nuxt.options.experimental.headNext = true;
    if (!nuxt.options.dev && config.redirectToCanonicalSiteUrl) {
      addServerHandler({
        handler: resolve(runtimeDir, "./server/middleware/redirectCanonical"),
        middleware: true
      });
    }
    nuxt.options.alias["#seo-utils"] = runtimeDir;
    nuxt.options.runtimeConfig.public["seo-utils"] = defu(nuxt.options.runtimeConfig.public["seo-utils"] || {}, {
      canonicalQueryWhitelist: config.canonicalQueryWhitelist || [
        "page",
        "sort",
        "filter",
        "search",
        "q",
        "category",
        "tag"
      ],
      canonicalLowercase: config.canonicalLowercase
    });
    if (config.extendNuxtConfigAppHeadSeoMeta)
      extendNuxtConfigAppHeadSeoMeta();
    if (config.setupNuxtConfigAppHeadWithMoreDefaults)
      setupNuxtConfigAppHeadWithMoreDefaults(nuxt);
    if (config.extendNuxtConfigAppHeadTypes)
      extendNuxtConfigAppHeadTypes();
    addTypeTemplate({
      filename: "module/nuxt-seo-utils.d.ts",
      getContents: (data) => {
        const typesPath = relative(resolve(data.nuxt.options.rootDir, data.nuxt.options.buildDir, "module"), resolve("runtime/types"));
        const types = `  interface NitroRouteRules {
     seoMeta?: import('${typesPath}').MetaFlatSerializable
     head?: import('${typesPath}').Head
  }
  interface NitroRouteConfig {
    seoMeta?: import('${typesPath}').MetaFlatSerializable
    head?: import('${typesPath}').Head
  }`;
        return `// Generated by nuxt-seo-utils

import type { RobotsContext } from '#robots/types'

declare module 'nitropack/types' {
${types}
}

declare module 'nitropack' {
${types}
}


declare module '@nuxt/schema' {
  interface AppHeadMetaObject { seoMeta?: import('${typesPath}').MetaFlatSerializable }
}

declare module 'nuxt/schema' {
  interface AppHeadMetaObject { seoMeta?: import('${typesPath}').MetaFlatSerializable }
}

export {}
`;
      }
    }, {
      nitro: true,
      nuxt: true
    });
    const appRuntimeDir = resolve(runtimeDir, "./app");
    if (config.treeShakeUseSeoMeta)
      addVitePlugin(UnheadVite(), {
        prepend: true
      });
    if (config.automaticOgAndTwitterTags)
      addPlugin({ src: resolve(appRuntimeDir, "plugins", "inferSeoMetaPlugin") });
    if (config.mergeWithSiteConfig)
      addPlugin({ src: resolve(appRuntimeDir, "plugins", "siteConfig") });
    if (config.extendRouteRules)
      addPlugin({ src: resolve(appRuntimeDir, "plugins", "0.routeRules") });
    if (config.fixRequiredAbsoluteMetaTagsLinks)
      addPlugin({ src: resolve(appRuntimeDir, "plugins", "1.absoluteImageUrls.server"), mode: "server" });
  }
});

export { module as default };
