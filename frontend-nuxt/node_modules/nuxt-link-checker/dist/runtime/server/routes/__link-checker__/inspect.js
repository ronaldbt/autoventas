import { useNitroOrigin, useRuntimeConfig, useSiteConfig } from "#imports";
import { createDefu } from "defu";
import Fuse from "fuse.js";
import { defineEventHandler, readBody } from "h3";
import { fixSlashes } from "nuxt-site-config/urls";
import { resolve } from "pathe";
import { generateFileLinkDiff, generateFileLinkPreviews, getLinkResponse, inspect, isNonFetchableLink, lruFsCache } from "../../../shared/index.js";
const merger = createDefu((obj, key, value) => {
  if (Array.isArray(obj[key]) && Array.isArray(value))
    obj[key] = Array.from(/* @__PURE__ */ new Set([...obj[key], ...value]));
  return obj[key];
});
function mergeOnKey(arr, key) {
  const res = {};
  arr.forEach((item) => {
    const k = item[key];
    res[k] = merger(item, res[k] || {});
  });
  return Object.values(res);
}
function isInternalRoute(path) {
  const lastSegment = path.split("/").pop() || path;
  return lastSegment.includes(".") || path.startsWith("/__") || path.startsWith("@");
}
export default defineEventHandler(async (e) => {
  const { tasks, ids, path } = await readBody(e);
  const runtimeConfig = useRuntimeConfig().public["nuxt-link-checker"] || {};
  const partialCtx = {
    ids,
    fromPath: fixSlashes(false, path),
    siteConfig: useSiteConfig(e)
  };
  lruFsCache.clear();
  const links = await $fetch("/__link-checker__/links");
  const pageSearch = new Fuse(mergeOnKey(links, "link"), {
    keys: ["link", "title"],
    threshold: 0.5
  });
  return Promise.all(
    tasks.map(async ({ link, paths, textContent }) => {
      if (isNonFetchableLink(link) || isInternalRoute(link))
        return { passes: true };
      const response = await getLinkResponse({
        link,
        timeout: runtimeConfig.fetchTimeout,
        fetchRemoteUrls: runtimeConfig.fetchRemoteUrls,
        baseURL: useNitroOrigin(e),
        isInStorage() {
          return false;
        }
      });
      const result = inspect({
        ...partialCtx,
        link,
        textContent,
        pageSearch,
        response,
        skipInspections: runtimeConfig.skipInspections
      });
      const filePaths = [
        resolve(runtimeConfig.rootDir, links.find((l) => l.file && l.link === path)?.file),
        ...paths.map((p) => {
          const [filepath] = p.split(":");
          return filepath;
        })
      ].filter(Boolean);
      if (!result.passes) {
        result.sources = (await Promise.all(filePaths.map(async (filepath) => await generateFileLinkPreviews(filepath, link)))).filter((s) => s.previews.length);
        result.diff = await Promise.all((result.sources || []).map(async ({ filepath }) => generateFileLinkDiff(filepath, link, result.fix)));
      }
      return result;
    })
  );
});
